<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>ESP-IDF Vulnerabilities</title>
		<link rel="stylesheet" href="css/style.css">
	</head>
	<body>
		<header>
			<div class="site-header">
				<h1 class="site-title"><a href=".">ESP-IDF Vulnerabilities</a></h1>
				<img class="site-logo" src="images/espressif-logo.png" alt="Espressif Logo">
			</div>
		</header>
		<main>
			
    <h3>v5.1.5</h3>
    <table class="release-table">
    <tr class=odd><td></td><td></td></tr>
<tr class=odd><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-49195">CVE-2024-49195</a></td></tr>
<tr class=odd><td>Vulnerable:</td><td><div class="red">yes</div></td></tr>
<tr class=odd><td>Package:</td><td>mbed_tls</td></tr>
<tr class=odd><td>Package Version:</td><td>3.6.1</td></tr>
<tr class=odd><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=odd><td>CVSS Score:</td><td>9.8</td></tr>
<tr class=odd><td>CVSS Severity:</td><td>CRITICAL</td></tr>
<tr class=odd><td>CVSS Vector String:</td><td>CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H</td></tr>
<tr class=odd><td>CPE:</td><td>cpe:2.3:a:arm:mbed_tls:3.6.1:*:*:*:*:*:*:*</td></tr>
<tr class=odd><td>Description:</td><td>Mbed TLS 3.5.x through 3.6.x before 3.6.2 has a buffer underrun in pkwrite when writing an opaque key pair</td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=even><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-27809">CVE-2025-27809</a></td></tr>
<tr class=even><td>Vulnerable:</td><td><div class="red">yes</div></td></tr>
<tr class=even><td>Package:</td><td>mbed_tls</td></tr>
<tr class=even><td>Package Version:</td><td>3.6.1</td></tr>
<tr class=even><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=even><td>CVSS Score:</td><td>5.4</td></tr>
<tr class=even><td>CVSS Severity:</td><td>MEDIUM</td></tr>
<tr class=even><td>CVSS Vector String:</td><td>CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N</td></tr>
<tr class=even><td>CPE:</td><td>cpe:2.3:a:arm:mbed_tls:3.6.1:*:*:*:*:*:*:*</td></tr>
<tr class=even><td>Description:</td><td>Mbed TLS before 2.28.10 and 3.x before 3.6.3, on the client side, accepts servers that have trusted certificates for arbitrary hostnames unless the TLS client application calls mbedtls_ssl_set_hostname.</td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=odd><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-49600">CVE-2025-49600</a></td></tr>
<tr class=odd><td>Vulnerable:</td><td><div class="red">yes</div></td></tr>
<tr class=odd><td>Package:</td><td>mbed_tls</td></tr>
<tr class=odd><td>Package Version:</td><td>3.6.1</td></tr>
<tr class=odd><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=odd><td>CVSS Score:</td><td>4.9</td></tr>
<tr class=odd><td>CVSS Severity:</td><td>MEDIUM</td></tr>
<tr class=odd><td>CVSS Vector String:</td><td>CVSS:3.1/AV:P/AC:H/PR:N/UI:N/S:C/C:N/I:H/A:N</td></tr>
<tr class=odd><td>CPE:</td><td>cpe:2.3:a:arm:mbed_tls:3.6.1:*:*:*:*:*:*:*</td></tr>
<tr class=odd><td>Description:</td><td>In MbedTLS 3.3.0 before 3.6.4, mbedtls_lms_verify may accept invalid signatures if hash computation fails and internal errors go unchecked, enabling LMS (Leighton-Micali Signature) forgery in a fault scenario. Specifically, unchecked return values in mbedtls_lms_verify allow an attacker (who can induce a hardware hash accelerator fault) to bypass LMS signature verification by reusing stale stack data, resulting in acceptance of an invalid signature. In mbedtls_lms_verify, the return values of the internal Merkle tree functions create_merkle_leaf_value and create_merkle_internal_value are not checked. These functions return an integer that indicates whether the call succeeded or not. If a failure occurs, the output buffer (Tc_candidate_root_node) may remain uninitialized, and the result of the signature verification is unpredictable. When the software implementation of SHA-256 is used, these functions will not fail. However, with hardware-accelerated hashing, an attacker could use fault injection against the accelerator to bypass verification.</td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=even><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-49601">CVE-2025-49601</a></td></tr>
<tr class=even><td>Vulnerable:</td><td><div class="red">yes</div></td></tr>
<tr class=even><td>Package:</td><td>mbed_tls</td></tr>
<tr class=even><td>Package Version:</td><td>3.6.1</td></tr>
<tr class=even><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=even><td>CVSS Score:</td><td>4.8</td></tr>
<tr class=even><td>CVSS Severity:</td><td>MEDIUM</td></tr>
<tr class=even><td>CVSS Vector String:</td><td>CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:L</td></tr>
<tr class=even><td>CPE:</td><td>cpe:2.3:a:arm:mbed_tls:3.6.1:*:*:*:*:*:*:*</td></tr>
<tr class=even><td>Description:</td><td>In MbedTLS 3.3.0 before 3.6.4, mbedtls_lms_import_public_key does not check that the input buffer is at least 4 bytes before reading a 32-bit field, allowing a possible out-of-bounds read on truncated input. Specifically, an out-of-bounds read in mbedtls_lms_import_public_key allows context-dependent attackers to trigger a crash or limited adjacent-memory disclosure by supplying a truncated LMS (Leighton-Micali Signature) public-key buffer under four bytes. An LMS public key starts with a 4-byte type indicator. The function mbedtls_lms_import_public_key reads this type indicator before validating the size of its input.</td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=odd><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2025-52497">CVE-2025-52497</a></td></tr>
<tr class=odd><td>Vulnerable:</td><td><div class="red">yes</div></td></tr>
<tr class=odd><td>Package:</td><td>mbed_tls</td></tr>
<tr class=odd><td>Package Version:</td><td>3.6.1</td></tr>
<tr class=odd><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=odd><td>CVSS Score:</td><td>4.8</td></tr>
<tr class=odd><td>CVSS Severity:</td><td>MEDIUM</td></tr>
<tr class=odd><td>CVSS Vector String:</td><td>CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:L</td></tr>
<tr class=odd><td>CPE:</td><td>cpe:2.3:a:arm:mbed_tls:3.6.1:*:*:*:*:*:*:*</td></tr>
<tr class=odd><td>Description:</td><td>Mbed TLS before 3.6.4 has a PEM parsing one-byte heap-based buffer underflow, in mbedtls_pem_read_buffer and two mbedtls_pk_parse functions, via untrusted PEM input.</td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=even><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28115">CVE-2024-28115</a></td></tr>
<tr class=even><td>Vulnerable:</td><td><div class="green">no</div></td></tr>
<tr class=even><td>Not Applicable:</td><td>Affects only ARMv7-M MPU ports, and ARMv8-M ports with Memory Protected Unit (MPU) support enabled</td></tr>
<tr class=even><td>Package:</td><td>freertos</td></tr>
<tr class=even><td>Package Version:</td><td>10.4.3</td></tr>
<tr class=even><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=even><td>CVSS Score:</td><td>8.8</td></tr>
<tr class=even><td>CVSS Severity:</td><td>HIGH</td></tr>
<tr class=even><td>CVSS Vector String:</td><td>CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H</td></tr>
<tr class=even><td>CPE:</td><td>cpe:2.3:o:amazon:freertos:10.4.3:*:*:*:*:*:*:*</td></tr>
<tr class=even><td>Description:</td><td>FreeRTOS is a real-time operating system for microcontrollers. FreeRTOS Kernel versions through 10.6.1 do not sufficiently protect against local privilege escalation via Return Oriented Programming techniques should a vulnerability exist that allows code injection and execution. These issues affect ARMv7-M MPU ports, and ARMv8-M ports with Memory Protected Unit (MPU) support enabled (i.e. `configENABLE_MPU` set to 1). These issues are fixed in version 10.6.2 with a new MPU wrapper. </td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=odd><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43997">CVE-2021-43997</a></td></tr>
<tr class=odd><td>Vulnerable:</td><td><div class="green">no</div></td></tr>
<tr class=odd><td>Not Applicable:</td><td>This vulnerability only affects ARMv7-M and ARMv8-M ports of FreeRTOS and hence does not affect Espressif SoCs which are not based on these architectures.</td></tr>
<tr class=odd><td>Package:</td><td>freertos</td></tr>
<tr class=odd><td>Package Version:</td><td>10.4.3</td></tr>
<tr class=odd><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=odd><td>CVSS Score:</td><td>7.8</td></tr>
<tr class=odd><td>CVSS Severity:</td><td>HIGH</td></tr>
<tr class=odd><td>CVSS Vector String:</td><td>CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H</td></tr>
<tr class=odd><td>CPE:</td><td>cpe:2.3:o:amazon:freertos:10.4.3:*:*:*:*:*:*:*</td></tr>
<tr class=odd><td>Description:</td><td>FreeRTOS versions 10.2.0 through 10.4.5 do not prevent non-kernel code from calling the xPortRaisePrivilege internal function to raise privilege. FreeRTOS versions through 10.4.6 do not prevent a third party that has already independently gained the ability to execute injected code to achieve further privilege escalation by branching directly inside a FreeRTOS MPU API wrapper function with a manually crafted stack frame. These issues affect ARMv7-M MPU ports, and ARMv8-M ports with MPU support enabled (i.e. configENABLE_MPU set to 1). These are fixed in V10.5.0 and in V10.4.3-LTS Patch 3.</td></tr>
<tr class=odd><td></td><td></td></tr>
<tr class=even><td></td><td></td></tr>
<tr class=even><td>ID:</td><td><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-52160">CVE-2023-52160</a></td></tr>
<tr class=even><td>Vulnerable:</td><td><div class="green">no</div></td></tr>
<tr class=even><td>Not Applicable:</td><td>The relevant fix has been patched with https://github.com/espressif/esp-idf/commit/59a62f2af65945f92d475089f9ce66fce56cc737</td></tr>
<tr class=even><td>Package:</td><td>wpa_supplicant</td></tr>
<tr class=even><td>Package Version:</td><td>2.10</td></tr>
<tr class=even><td>CVSS Version:</td><td>3.1</td></tr>
<tr class=even><td>CVSS Score:</td><td>6.5</td></tr>
<tr class=even><td>CVSS Severity:</td><td>MEDIUM</td></tr>
<tr class=even><td>CVSS Vector String:</td><td>CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N</td></tr>
<tr class=even><td>CPE:</td><td>cpe:2.3:a:w1.fi:wpa_supplicant:2.10:*:*:*:*:*:*:*</td></tr>
<tr class=even><td>Description:</td><td>The implementation of PEAP in wpa_supplicant through 2.10 allows authentication bypass. For a successful attack, wpa_supplicant must be configured to not verify the network's TLS certificate during Phase 1 authentication, and an eap_peap_decrypt vulnerability can then be abused to skip Phase 2 authentication. The attack vector is sending an EAP-TLV Success packet instead of starting Phase 2. This allows an adversary to impersonate Enterprise Wi-Fi networks.</td></tr>
<tr class=even><td></td><td></td></tr>

    </table>
    
		</main>
	</body>
</html>
